# Frontenditor

Frontenditor.

Okay, so yeah! Frontenditor. This project is inspired by Real-time HTML Editor, EditPad, Smart Text Editor, and CodePen. I should have made STE pascal-case I guess, lol.

I have had this concept for a while, where I want to make it absurdly easy to get into web development. I love the notion of that. Not that it should cut all the corners and make it so you don't have to learn anything. Far from the opposite. I want it to be extremely trivial to iterate, experiment, work, and keep growing your learning journey.

This project is lifting off from where STE started, and I think maybe it could be the next iteration of what STE might become. Using full-blown projects like Git are great, and I fully use them today. I wouldn't ask for anything else. This project aims to implement parts of what make Git so great. I also plan to integrate with Git as well.

Picture how CodePen works. You can see changes in real-time, as you type them (albeit CodePen uses debouncing, it's not totally totally real-time). I like how easy it is to set up a page. You don't have to worry about formatting your entire HTML all perfect, just let it handle managing the document for you. While again, I don't regret fully learning the entire HTML document structure, it is a hindrance for getting started. I want it to be easier for people to use, and iterate.

You shouldn't need to have a computer with a terminal to get version control.

Again, I am not trying to make a Git replacement. If anything, this is the launchpad one would use before getting into using and needed full tools like frameworks, command line tools, compilers, things like that.

Maybe out of scope, but also not out of the picture, I have also had the inkling of interest to build my own web language/compiler/abstraction, to where things are simpler to compose frontends. I very much love how SolidJS works. I just wish that, once again, one wouldn't have to know how to use a terminal, npm, Git, and TypeScript to get started with it.

One of the largest pitfalls for me starting out was that I built projects which fell to the weight of the technical debt I introduced into the project, merely because I didn't know great programming techniques and practices. Albeit probably naive for me to think, but I would like to assume that removing the barrier of entry for these nice abstractions may be a key to allow for more manageable code to be built by people getting into programming. One of my turn-aways when getting started was that I didn't want to use React because I was on a Chromebook, and I merely wanted to learn how to program, I didn't want to get a new computer just to install dependencies, manage packages, run commands in the terminal, and start a localhost server. I just wanted to get a frontend running. So this was what funded my personal investment into making Smart Text Editor, and with that, my knowledge about how to program on the frontend. That also taught me about dogfooding. It couldn't have been any more neat than that. I thought I was the odd one out for not using all of the tools like all the cool kids on the block were using (namely, IntelliSense, VSCode, React, Webpack, etc). I am glad I learned how to build projects without those. While today, I am no longer against using those tools, when they are applicable, I now, and still see, that those do not and never did make the barrier for entry easier for younger devs.

Why not teach about version control without needing to use the terminal? Why not teach about signals and state management, before needing to learn about what a compiler, transpiler, and bundler are? Let alone a live server, module graph, CommonJS vs ESM, TypeScript? Again, all of these make life easier for me now, at least from what I can tell. My projects are more secure now, and I catch errors before they go to production. But I also felt I haven't made anything new or groundbreaking in years. I love making my projects entirely type-safe. I love ensuring that it all runs and is built using Vite with GitHub Actions. But it does not make me more productive, or more experiment-based. I loved that about my STE days. Albeit, I was also in that phase to just learn as much as possible. When you don't know how to use all of those tools, nor why you would want to in the first place, the only thing you want to do is build personal "toys" to learn various things to tinker with. I still have all of my demos on my computer. They are just comprised of some HTML, CSS, and JS. They might show how to style the viewport to fit on notched iPhones, for example. Maybe it shows how to add custom right-click context menus with HTML and JS. Or maybe it's saving files with the File API, and or the File Systems Access API. Or it's writing NBT parsing logic with Uint8Array buffers, and traversing them as JS objects. Small, experimental, iterable. Not entire suites of monorepos and projects maintained over the course of entropy. Code that is documented, preserved, yet maybe not revisited.

Git commits and READMEs are awesome, you can write about where you are at while working on a project, and document what is/isn't working, and what has yet to be done. Singular demo files don't allow for this very nicely. Let alone if you wanted to share it with a friend.

A lot of sites tend to kind of handle this. Say you have something like CodePen, I mention once again. It saves it on someone else's server. It's nice to have a link, I'll give you that. Yet it's not versioned, nor is there much metadata about the project. Say like versioned commits/snapshots. You might want to include images in your site. For a single HTML file, you'd have to embed it inside the file as a super long Base64 URL, or host them on a separate site, to reference from there. But then they aren't version controlled. If you save the images as Base64, then you can't diff the HTML file very nicely.

This project is both an entry point for people to get into nice programming practices and iteration/archival, while remaining available to expand into the greater dev ecosystem once that is something that is desired. This is not the end-all-be-all. You would run a *currently theoretical* script to extract the contents of this project archive into a fully-composed Git project, which would then compile the contents of the project, and diff them as appropriate. You then would be able to work on it as if you had started it with Git in the first place.

This currently doesn't have the goal of embedding TypeScript, while I do love TypeScript. Same with regular bundle-based frameworks. This is not just the playground for React or Solid. While maybe you could get those working here, it isn't that. And I mean, yes it would be great to use this for that as well. You could just use CDNs for referencing dependencies and things like that. Go all ahead! Using versioned links works really well in this case too, as this project will include that in the snapshots.

The goal isn't to necessarily edit the files made by this with something like VSCode. This project is meant to be built for those who are not yet to the place of using/wanting to use VSCode.

I am not one to enjoy proprietary files or formats. I don't want to create that here if I don't have to. If anything, I will just use something like JSON and or GZIP for all of this. Very simple to work with, traverse, and work with outside of this website specifically, and the browser/JS environment. That's the last thing I would want, is for people to have their projects to be locked inside a vendor-based format, which doesn't have a way out. I hate that stuff. That's one of the biggest things I seem to be passionate about for some reason. Whether it's about intentional nefarious vendor lock-in, or incidental, I seem to be into cracking file formats. I like the sentiment that there's data in there, and how you perceive it and or discern it is merely the defining factor as to whether it is usable. The data is there, whether you are able to cract the Rubik's cube or not. Say like how people save video files inside of Minecraft world block structures, this is fascinating to me, or if you were to write binary data into the chip isles of Walmart. Maybe it's related to there being answers out in the Cosmos, and we just don't know to look for it. There's plenty of things out there like this.

But yeah, stay tuned!

Brandon
